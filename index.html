<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enter</title>

  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500&display=swap" rel="stylesheet" />

  <style>
    :root {
      --bg: #000;
      --fg: #eaeaea;
      --muted: #888;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, Helvetica, Arial, sans-serif;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* --- Grok-style starfield layer (behind content, above body background) --- */
    #grok-starfield{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      opacity: 0;
      transition: opacity 10s ease;
      transform: translateZ(0);
      will-change: transform;
      z-index: 0;
      pointer-events: none;
    }

    #grok-starfield.starfield-visible {
      opacity: 1;
    }
    /* Optional: subtle vignette overlay for depth (very low opacity) */
    body::before{
      content: "";
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background:
        radial-gradient(1200px 800px at 50% 35%,
          rgba(0,0,0,0.00) 0%,
          rgba(0,0,0,0.10) 70%,
          rgba(0,0,0,0.18) 100%);
      opacity: 0; /* off by default; enabled in dark theme below */
    }

    body[data-theme="dark"]::before{
      opacity: 1;
    }

    /* Ensure main content sits above the canvas */
    .enter {
      text-align: center;
      position: relative;
      z-index: 1;
    }

    .enter .intro {
      text-align: left;
      font-family: "IBM Plex Sans", -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, Helvetica, Arial, sans-serif;
      font-size: 0.75rem;
      font-weight: 400;
      line-height: 1.6;
      letter-spacing: 0.02em;
      max-width: 420px;
      margin: 0 0 32px;
      color: var(--muted);
      opacity: 0;
      animation: fadeInSoft 3200ms ease forwards;
      animation-delay: 450ms;
    }

    .enter .intro .line-1 {
      display: inline-block;
      font-weight: 500;
      color: var(--fg);
      opacity: 0.9;
    }

    .enter .intro .line-2 {
      display: inline-block;
      font-weight: 400;
      opacity: 0.65;
    }

    .enter a {
      display: inline-block;
      padding: 12px 28px;
      border: 1px solid var(--fg);
      color: var(--fg);
      text-decoration: none;
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      transition: background 0.2s ease, color 0.2s ease;
      opacity: 0;
      animation: fadeInSoft 3200ms ease forwards;
      animation-delay: 150ms;
    }

    .enter a:hover {
      background: var(--fg);
      color: var(--bg);
    }

    @keyframes fadeInSoft {
      from { opacity: 0; }
      to   { opacity: 1; }
    }

    @media (prefers-reduced-motion: reduce) {
      .enter a,
      .enter .intro {
        animation: none;
        opacity: 1;
      }

      #grok-starfield {
        transition: none;
        opacity: 1;
      }
    }
  </style>
</head>

<body data-theme="dark">
  <canvas id="grok-starfield" aria-hidden="true"></canvas>

  <div class="enter">
    <p class="intro">
      <span class="line line-1">An AI takeover is inevitable.</span><br>
      <span class="line line-2">In the meantime, learn how to communicate with and use language models through prompt engineering.</span>
    </p>
    <a href="site.html">Enter</a>
  </div>

  <script>
    const STARFIELD_DELAY_MS = 7000;

    window.setTimeout(() => {
      (() => {
        const canvas = document.getElementById("grok-starfield");
        if (!canvas) return;

        const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
        if (!ctx) return;

        const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        if (!reduceMotion) {
          requestAnimationFrame(() => canvas.classList.add("starfield-visible"));
        }

        const DPR = Math.min(window.devicePixelRatio || 1, 2);

        const SETTINGS = {
          density: 0.00011,          // stars per pixel^2 (auto-caps below)
          maxStars: 650,
          minStars: 220,

          // motion: make it perceptible but still subtle (fix "static")
          baseDrift: 2.6,            // px/s baseline drift
          parallax: 2.4,             // deeper layer moves more

          // twinkle: only some stars pulse, slowly, at random times
          twinkleFraction: 0.22,
          twinkleBoost: 0.85,

          // shooting stars
          shootMinMs: 10000,
          shootMaxMs: 26000,

          // visual
          baseAlphaDark: 0.715,
          baseAlphaLight: 0.234,
          vignetteDark: 0.20,
          vignetteLight: 0.06,
        };

        let w = 0, h = 0;
        let stars = [];
        let meteors = [];
        let raf = 0;

        let nextShootAt = 0;
        let lastT = performance.now();

        const prefersReducedMotion = reduceMotion;

        function rand(min, max) { return min + Math.random() * (max - min); }

        function isDarkTheme() {
          return document.body?.dataset?.theme === "dark";
        }

        function scheduleNextShoot(now) {
          nextShootAt = now + rand(SETTINGS.shootMinMs, SETTINGS.shootMaxMs);
        }

        function resize() {
          // Use viewport size (more reliable than clientWidth/Height for fixed canvas)
          w = Math.max(1, window.innerWidth || document.documentElement.clientWidth || 1);
          h = Math.max(1, window.innerHeight || document.documentElement.clientHeight || 1);

          canvas.width = Math.floor(w * DPR);
          canvas.height = Math.floor(h * DPR);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";

          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

          initStars();
        }

        function initStars() {
          const area = w * h;
          const count = Math.min(
            SETTINGS.maxStars,
            Math.max(SETTINGS.minStars, Math.floor(area * SETTINGS.density))
          );

          stars = new Array(count).fill(0).map(() => {
            const z = Math.random(); // 0..1 depth layer
            const size = rand(0.35, 1.15) * (0.65 + z * 0.55) * 1.1; // small, mostly crisp
            const alpha = rand(0.22, 0.85);
            const dir = rand(0, Math.PI * 2);
            const speed = (SETTINGS.baseDrift + rand(-0.6, 1.1)) * (0.45 + z * SETTINGS.parallax);

            const tw = Math.random() < SETTINGS.twinkleFraction;
            const now = performance.now();
            const twDur = rand(2600, 6200);    // slow pulse duration
            const twGap = rand(5200, 18000);   // random quiet time between pulses
            const twStartAt = now + rand(800, 9000);

            return {
              x: rand(0, w),
              y: rand(0, h),
              z,
              r: size,
              a: alpha,
              vx: Math.cos(dir) * speed,
              vy: Math.sin(dir) * speed,
              tw,
              twStartAt,
              twDur,
              twGap,
            };
          });

          meteors = [];
          scheduleNextShoot(performance.now());
        }

        function wrapStar(s) {
          const pad = 40;
          if (s.x < -pad) s.x = w + pad;
          else if (s.x > w + pad) s.x = -pad;
          if (s.y < -pad) s.y = h + pad;
          else if (s.y > h + pad) s.y = -pad;
        }

        function spawnMeteor() {
          const startX = rand(-0.2 * w, 0.9 * w);
          const startY = rand(-0.35 * h, 0.2 * h);

          // down-right-ish, like Grok
          const angle = rand(Math.PI * 0.18, Math.PI * 0.33);
          const speed = rand(750, 1200);

          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;

          meteors.push({
            x: startX,
            y: startY,
            vx,
            vy,
            life: 0,
            maxLife: rand(0.55, 0.95),
            len: rand(180, 320),
            width: rand(1.0, 1.7),
          });
        }

        function drawVignette() {
          const dark = isDarkTheme();
          const alpha = dark ? SETTINGS.vignetteDark : SETTINGS.vignetteLight;

          const cx = w / 2;
          const cy = h / 2;
          const r = Math.max(w, h) * 0.85;

          const g = ctx.createRadialGradient(cx, cy * 0.85, 0, cx, cy, r);
          g.addColorStop(0, "rgba(0,0,0,0)");
          g.addColorStop(1, `rgba(0,0,0,${alpha})`);

          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, w, h);
        }

        function twinkleAlpha(s, now) {
          if (!s.tw) return 1;

          if (now < s.twStartAt) return 1;

          const t = (now - s.twStartAt) / s.twDur;
          if (t >= 1) {
            // schedule next pulse
            s.twStartAt = now + s.twGap + rand(-800, 1200);
            s.twDur = rand(2600, 6200);
            s.twGap = rand(5200, 18000);
            return 1;
          }

          // smooth in/out (0->1->0)
          const pulse = Math.sin(Math.min(1, t) * Math.PI);
          return 1 + pulse * SETTINGS.twinkleBoost;
        }

        function drawStars(now, dt) {
          const dark = isDarkTheme();
          const baseAlpha = dark ? SETTINGS.baseAlphaDark : SETTINGS.baseAlphaLight;

          // subtle global drift so even tiny per-star motion reads as "alive"
          const globalX = Math.sin(now * 0.00006) * 6;
          const globalY = Math.cos(now * 0.00005) * 4;

          for (const s of stars) {
            s.x += s.vx * dt;
            s.y += s.vy * dt;
            wrapStar(s);

            const tw = twinkleAlpha(s, now);
            const depthDim = 0.55 + 0.45 * s.z;
            const a = baseAlpha * s.a * depthDim * tw;

            if (a <= 0.002) continue;

            const x = s.x + globalX * (0.3 + s.z);
            const y = s.y + globalY * (0.3 + s.z);

            // crisp core
            ctx.globalAlpha = a;
            ctx.fillStyle = "rgba(255,255,255,1)";
            ctx.beginPath();
            ctx.arc(x, y, Math.max(0.35, s.r * 0.55), 0, Math.PI * 2);
            ctx.fill();

            // tiny halo only for some brighter stars (keeps most crisp)
            if (a > (dark ? 0.38 : 0.14) && s.r > 0.6) {
              ctx.globalAlpha = a * 0.18;
              ctx.beginPath();
              ctx.arc(x, y, s.r * 1.9, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          ctx.globalAlpha = 1;
        }

        function drawMeteors(dt) {
          for (let i = meteors.length - 1; i >= 0; i--) {
            const m = meteors[i];
            m.life += dt;
            m.x += m.vx * dt;
            m.y += m.vy * dt;

            const p = m.life / m.maxLife;
            if (p >= 1 || m.x > w + 500 || m.y > h + 500) {
              meteors.splice(i, 1);
              continue;
            }

            const fade = Math.sin(Math.min(1, p) * Math.PI); // smooth in/out
            const alpha = 0.70 * fade;

            const speed = Math.hypot(m.vx, m.vy) || 1;
            const nx = m.vx / speed;
            const ny = m.vy / speed;

            const x2 = m.x - nx * m.len;
            const y2 = m.y - ny * m.len;

            ctx.globalAlpha = alpha;
            ctx.lineWidth = m.width;
            ctx.lineCap = "round";

            const grad = ctx.createLinearGradient(m.x, m.y, x2, y2);
            grad.addColorStop(0.0, "rgba(255,255,255,1)");
            grad.addColorStop(0.35, "rgba(210,230,255,0.55)");
            grad.addColorStop(1.0, "rgba(255,255,255,0)");

            ctx.strokeStyle = grad;
            ctx.beginPath();
            ctx.moveTo(m.x, m.y);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.globalAlpha = 1;
          }
        }

        function frame(now) {
          if (prefersReducedMotion) {
            // still render a static nice background once
            ctx.clearRect(0, 0, w, h);
            drawStars(now, 0);
            drawVignette();
            return;
          }

          const dt = Math.min(0.05, Math.max(0.001, (now - lastT) / 1000));
          lastT = now;

          ctx.clearRect(0, 0, w, h);

          drawStars(now, dt);
          drawMeteors(dt);
          drawVignette();

          if (now >= nextShootAt && meteors.length === 0 && Math.random() < 0.9) {
            spawnMeteor();
            scheduleNextShoot(now);
          }

          raf = requestAnimationFrame(frame);
        }

        function start() {
          cancelAnimationFrame(raf);
          lastT = performance.now();
          raf = requestAnimationFrame(frame);
        }

        // robust resize handling (donâ€™t rely only on ResizeObserver)
        window.addEventListener("resize", () => {
          resize();
          start();
        }, { passive: true });

        if ("ResizeObserver" in window) {
          const ro = new ResizeObserver(() => {
            resize();
            start();
          });
          ro.observe(document.documentElement);
        }

        resize();
        start();
      })();
    }, STARFIELD_DELAY_MS);
  </script>
</body>
</html>
